

Read file: src/types.ts
На основе анализа кода я вижу несколько проблем с распределением логики между фронтендом и бэкендом. Вот мои рекомендации по улучшению серверной части, которые помогут упростить клиентскую логику:

## 1. Валидация действий игрока

Сейчас на фронтенде реализована сложная логика валидации ходов в методах `canAttack` и `canDefend`. Эти проверки должны дублировать логику сервера, что ведет к неконсистентности и усложнению поддержки кода.

**Решение**: Добавить API-методы для предварительной валидации ходов:
```
ValidateAttack(cardId: string) -> boolean
ValidateDefend(cardId: string, slotId: number) -> boolean
```

## 2. Управление очередью и пендинг-действиями

Фронтенд поддерживает очередь `pendingActions` для промежуточного состояния между отправкой карты и подтверждением хода сервером. Это создаёт сложную логику синхронизации.

**Решение**: Добавить события для промежуточных состояний:
```
CardActionAccepted - сервер принял действие
CardActionRejected - сервер отклонил действие
```

## 3. Анимации и состояния перемещения карт

Большая часть кода `gameService.ts` посвящена обработке анимаций и перемещений. Это UI-логика, но сейчас она смешана с бизнес-логикой.

**Решение**: Сервер должен отправлять более детальные события о перемещениях карт:
```
CardMoved: { 
  cardId: string, 
  source: 'hand' | 'table' | 'deck', 
  destination: 'hand' | 'table' | 'discard',
  playerId: string
}
```

## 4. Восстановление состояния после перезагрузки

Код использует сложную логику проверок `isReloadedPage` для определения, была ли страница перезагружена, и восстановления состояния.

**Решение**: Добавить отдельный API-метод для получения полного состояния игры:
```
GetFullGameState() -> { gameState, personalState, tableState, ... }
```

## 5. Обработка "паса"

Сейчас информация о пасе обрабатывается с таймером на фронтенде, который очищает сообщение через 2 секунды.

**Решение**: Сервер должен отправлять дополнительные события:
```
PlayerPassedStart - когда игрок начал пас
PlayerPassedEnd - когда информация о пасе должна быть скрыта
```

## 6. Обработка окончания раунда

Сейчас фронтенд пытается определить, как закончился раунд (защищающийся взял карты или отбился) по косвенным признакам.

**Решение**: Добавить специальные события:
```
RoundEnded: { 
  reason: 'allCardsBeaten' | 'defenderTookCards',
  defenderId: string 
}
```

## 7. Обновление слотов на столе

Сложная логика обновления слотов на основе `tableCards`.

**Решение**: Сервер должен отправлять напрямую структуру слотов:
```
TableSlotsUpdated: { slots: ISlot[] }
```

## Общие рекомендации:

1. Обработка всех правил игры должна быть на сервере
2. Клиент должен отвечать только за визуализацию и отправку действий пользователя
3. Сервер должен отправлять более гранулярные события о состоянии игры
4. Состояние игры должно полностью контролироваться сервером

Эти изменения сделают клиентский код значительно более простым, надежным и легким в поддержке.
